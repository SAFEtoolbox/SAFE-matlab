function [ Si, STi, Si_sd, STi_sd, Si_lb, STi_lb, Si_ub, STi_ub, Si_all, STi_all ] = vbsa_indices(YA,YB,YC,varargin)
%
% This function estimates the variance-based first-order indices
% (or 'main effects') and total-order ('total effects') indices 
% (Homma and Saltelli, 1996) by using the approximation technique 
% described e.g. in Saltelli et al. (2008) and (2010).
%
% Usage:
% [ Si, STi ] = vbsa_indices(YA,YB,YC)
% [ Si, STi, Si_sd, STi_sd ] = vbsa_indices(YA,YB,YC,Nboot)
% [ Si, STi, Si_sd, STi_sd, Si_lb,STi_lb,Si_ub,STi_ub ] = ...
%                              vbsa_indices(YA,YB,YC,Nboot)
% [ Si, STi, Si_sd, STi_sd, Si_lb,STi_lb,Si_ub,STi_ub ] = ... 
%                              vbsa_indices(YA,YB,YC,Nboot,alfa)
% [ Si, STi, Si_sd, STi_sd, Si_lb,STi_lb,Si_ub,STi_ub,Si_all,STi_all]=... 
%                              vbsa_indices(YA,YB,YC,Nboot,alfa)
%
%
% Input:
%    YA = set of output samples                              - vector (N,1)
%    YB = set of output samples (independent from YA)        - vector (N,1)
%    YC = set of output samples from resampling (*)        - vector (N*M,1)
% Nboot = number of resamples used for boostrapping (default:0)    - scalar
%  alfa = significance level for the confidence intervals estimated
%         by bootstrapping (default: 0.05)                         - scalar
%
%  ** [leave empty any optional argument to get default values] ** 
%
% Output:
%   Si  = estimates of first-order sensitivity indices (**)  - vector (1,M)
%  STi  = estimates of total effect sensitivity indices (**) - vector (1,M)
% Si_sd = standard deviation of estimated 'Si'               - vector (1,M) 
%                                        if Nboot>1, empty vector otherwise
%  STi_sd = standard deviation of estimated 'STi'           - same as Si_sd
%   Si_lb = lower bound of estimated 'Si'                   - same as Si_sd
%  STi_lb = lower bound of estimated 'STi'                  - same as Si_sd
%   Si_ub = upper bound of estimated 'Si'                   - same as Si_sd
%  STi_ub = upper bound of estimated 'STi'                  - same as Si_sd
%  Si_all = estimated 'Si' for each bootstrap resample      - (Nboot,M)
% STi_all = estimated 'STi' for each bootstrap resample     - (Nboot,M)
%
% NOTES:
%
% (*) By default, here we use the estimators described by Saltelli et al.
%     (2008) and Saltelli et al. (2010) (see comments in the code for
%     specific references to the equations implemented here!).
%     These are obtained from 3 sets of output samples (YA, YB and YC), 
%     which are obtained by model evaluation against three input matrices 
%     XA, XB and XC generated by the 'vbsa_resampling.m' function: 
%     - see example below about how to use 'vbsa_resampling' and 
%       'vb_firstorder_indices' sequentially; 
%     - see help of 'vbsa_resampling' to learn more about XA, XB and XC.
%
% (**) If bootstrapping is used, 'Si' and 'STi' are the average of the
%      respective Nboot estimates obtained at each bootstrap resampling.
%
% (***) If the vectors YA, YB or YC include any NaN values, the function  
%       will identify them and exclude them from further computation. 
%       A Warning message about the number of discarded NaN elements (and 
%       hence the actual number of samples used for estimating Si and STi) 
%       will be displayed.
%
% REFERENCES:
%
% Homma, T. and A., Saltelli (1996). Importance measures in global 
% sensitivity analysis of nonlinear models. 
% Reliability Engineering & System Safety, 52(1), 1-17.
%
% Saltelli et al. (2008), Global Sensitivity Analysis, The Primer, Wiley.
%
% Saltelli et al. (2010), Variance based sensitivity analysis of model 
% output. Design and estimator for the total sensitivity index, Computer 
% Physics Communications, 181, 259-270.
%
% EXAMPLE:
%
% fun_test  = 'ishigami_homma_function' ;
% M = 3 ;
% distrfun = 'unif' ;
% distrpar = [ -pi pi ];
% N = 1000;
% sampstrat = 'lhs' ;
% X = AAT_sampling(sampstrat,M,distrfun,distrpar,2*N);
% [ XA, XB, XC ] = vbsa_resampling(X) ;
% YA = model_evaluation(fun_test,XA);
% YB = model_evaluation(fun_test,XB);
% YC = model_evaluation(fun_test,XC);
% [ Si, STi ] = vbsa_indices(YA,YB,YC);

% This function is part of the SAFE Toolbox by F. Pianosi, F. Sarrazin 
% and T. Wagener at Bristol University (2015). 
% SAFE is provided without any warranty and for non-commercial use only. 
% For more details, see the Licence file included in the root directory 
% of this distribution.
% For any comment and feedback, or to discuss a Licence agreement for 
% commercial use, please contact: francesca.pianosi@bristol.ac.uk
% For details on how to cite SAFE in your publication, please see: 
% bristol.ac.uk/cabot/resources/safe-toolbox/

%%%%%%%%%%%%%%
% Check inputs
%%%%%%%%%%%%%%


[NA,n]=size(YA) ;
if n~=1; error('input ''YA'' must be a column vector'); end
[NB,n]=size(YB) ;
if n~=1; error('input ''YB'' must be a column vector'); end
[NC,n]=size(YC) ;
if n~=1; error('input ''YC'' must be a column vector'); end
if NA~=NB; error('input ''YA'' and ''YB'' must have the same number of rows'); end
M = NC/NA ;
if abs(M-round(M)); error('number of rows in input ''YC'' must be M*N, where N is the number of rows in ''YA'''); end
N = NA ;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Recover and check optional inputs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if nargin<4
    Nboot=0;
else
    Nboot=varargin{1};
    if ~isscalar(Nboot); error('''Nboot'' must be scalar'); end
    if Nboot<0; error('''Nboot'' must be positive' ); end
    if abs(Nboot-round(Nboot)); error('''Nboot'' must be an integer'); end
end
if nargin<5
    alfa=0.05;
else
    alfa=varargin{2};
    if ~isscalar(alfa); error('''alfa'' must be scalar'); end
    if any([alfa<0,alfa>1]); error('''alfa'' must be in [0,1]' ); end
end

%%%%%%%%%%%%%%%%%
% Compute indices
%%%%%%%%%%%%%%%%%

YC = reshape(YC,N,M) ;

Si_sd  = [];
STi_sd = [];
Si_lb  = [];
STi_lb = [];
Si_ub  = [];
STi_ub = [];

if Nboot>1
    bootsize = N ;
    B   = floor((rand(bootsize,Nboot)*N+1));
    Si_all  = nan(Nboot,M) ;
    STi_all = nan(Nboot,M) ;
    idxSi_all = nan(Nboot,M) ;
    idxSTi_all = nan(Nboot,M) ;
    
    for n=1:Nboot
        [ Si_all(n,:), STi_all(n,:), idxSi_all(n,:), idxSTi_all(n,:) ] = compute_indices(YA(B(:,n)),YB(B(:,n)),YC(B(:,n),:))   ;
    end
    Si      = mean(Si_all) ;
    Si_sd   = std(Si_all)  ;
    Si_lb   = sort(Si_all) ; Si_lb = Si_lb(max(1,round(Nboot*alfa/2)),:)    ;
    Si_ub   = sort(Si_all) ; Si_ub = Si_ub(round(Nboot*(1-alfa/2)),:);
    STi     = mean(STi_all) ;
    STi_sd  = std(STi_all)  ;
    STi_lb  = sort(STi_all) ; STi_lb = STi_lb(max(1,round(Nboot*alfa/2)),:)    ;
    STi_ub  = sort(STi_all) ; STi_ub = STi_ub(round(Nboot*(1-alfa/2)),:);

    % Print to screen a warning message if any NAN was found in YA,YB. YC:
    if sum(isnan(YA))+sum(isnan(YB))+sum(isnan(YC(:)))
    fprintf('\n WARNING:')
    if sum(isnan(YA))>0; fprintf('\n %d NaNs were found in YA',sum(isnan(YA))); end
    if sum(isnan(YB))>0; fprintf('\n %d NaNs were found in YB',sum(isnan(YB))); end
    if sum(isnan(YC(:)))>0; fprintf('\n %d NaNs were found in YC',sum(isnan(YC(:)))); end
    str = '%1.0f'; for i=2:M ; str = [str ' %1.0f']; end
    fprintf('\n Average number of samples that could be used to approximate main effects (Si) is:')
    fprintf('\nX%d:  %1.0f',[1:M;mean(idxSi_all)]);
    fprintf('\n Average number of samples that could be used to approximate total effects (STi) is:')
    fprintf('\nX%d:  %1.0f',[1:M;mean(idxSTi_all)]);
    fprintf('\n')
    end

    % Print to screen the sensitivity indices:
    fprintf('\n \t main    total    (average over %d bootstrap resamples)\n',Nboot);
    fprintf(' X%d:\t %1.4f\t %1.4f\n',[ 1:M; Si; STi ]);
    fprintf('\n sum:\t %1.4f\t %1.4f\n\n',[ sum(Si); sum(STi) ]);
    
else
    [ Si, STi, idxSi, idxSTi ] = compute_indices(YA,YB,YC)   ;   
    

    % Print to screen a warning message if any NAN was found in YA,YB. YC:
    if sum(isnan(YA))+sum(isnan(YB))+sum(isnan(YC(:)))
    fprintf('\n WARNING:')
    if sum(isnan(YA))>0; fprintf('\n %d NaNs were found in YA',sum(isnan(YA))); end
    if sum(isnan(YB))>0; fprintf('\n %d NaNs were found in YB',sum(isnan(YB))); end
    if sum(isnan(YC(:)))>0; fprintf('\n %d NaNs were found in YC',sum(isnan(YC(:)))); end
    str = '%d'; for i=2:M ; str = [str ' %d']; end
    fprintf('\n The number of samples that could be used to approximate main effects (Si) is:')
    fprintf('\nX%d:  %1.0f',[1:M;idxSi]);
    fprintf('\n The number of samples that could be used to approximate total effects (STi) is:')
    fprintf('\nX%d:  %1.0f',[1:M;idxSTi]);
    fprintf('\n')
    end

    % Print to screen the sensitivity indices:
    fprintf('\n \t main    total \n');
    fprintf(' X%d:\t %1.4f\t %1.4f\n',[ 1:M; Si; STi ]);
    fprintf('\n sum:\t %1.4f\t %1.4f\n\n',[ sum(Si); sum(STi) ]);

    
end

%%%% built-in function

function [ Si, STi, idxSi, idxSTi ] = compute_indices(YA,YB,YC)
%
%    YA - vector (N,1) %
%    YB - vector (N,1) %
%    YC - matrix (N,M) %

[N,M]=size(YC) ;
Si  = nan(1,M);
STi = nan(1,M);

nanB = isnan(YB) ;
nanA = isnan(YA) ;
idxSi = nan(1,M) ;
idxSTi = nan(1,M) ;

f0   = mean(YA(~nanA)) ;
VARy = mean(YA(~nanA).^2) - f0^2 ;

for i=1:M
    yCi=YC(:,i);
    
    nanC = isnan(yCi) ;
    
    idx  =  nanA | nanC ; % find indices where either YA or YCi is a NaN
    % and that will need to be excluded from computation
    
    Si(i)  = ( mean(YA(~idx).*yCi(~idx)) - f0^2 ) / VARy ;     
    % This is Eq (4.21) in Saltelli et al. (2008)
    % and also Eq. (12) in Saltelli et al. (2010), where the method is
    % attributed to Sobol (1993).
    
    idxSi(i) = sum(~idx) ; % save number of samples that could be actually
    % used for estimating main effects
    
    idx  =  nanB | nanC ; % find indices where either YB or YCi is a NaN
    % and that will need to be excluded from computation
    
    STi(i) = 1 -  ( mean(YB(~idx).*yCi(~idx)) - f0^2 ) / VARy ;
    % This is Eq (4.22) in Saltelli et al. (2008)
    
    idxSTi(i) = sum(~idx) ;% save number of samples that could be actually
    % used for estimating total effects
    
end


            
